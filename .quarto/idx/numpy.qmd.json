{"title":"Introduction to NumPy and friends","markdown":{"headingText":"Introduction to NumPy and friends","containsRefs":false,"markdown":"\nThe [NumPy](https://numpy.org/) package is _the_ key building block of the Python scientific ecosystem.\n\nIn this chapter we introduce a few of the key concepts. You should refer to the [documentation](https://numpy.org/doc/stable/user/index.html) for details. As with any mature software ecosystem, you should first __assume that what you want to achieve _can_ be achieved in a highly optimised way within the existing framework__, and only resort to creating your own solution if and when you satisfy yourself that this is not the case.\n\nThere are a huge number of resources for learning NumPy online. [This](https://cs231n.github.io/python-numpy-tutorial/) is one particular nice and compact tutorial.\n\n## Preamble: objects in Python\n\nEverything in Python is an _object_. For example `[1,2,3]` is a `list`:\n\n```{python}\nmy_list = [1, 2, 3]\ntype(my_list)\n```\n\nYou can think of an object as a container for _properties_ and _methods_, the latter being functions associated with the object. Properties and methods are accessed with the `.` syntax. For example, lists have the `append` method, which adds an element to the end of the list:\n\n```{python}\nmy_list.append(\"boop\")\nmy_list\n```\n\nWith IPython you can see all the available methods by hitting tab:\n\n![](assets/tab-complete.gif)\n\n::: {.callout-tip collapse=\"true\"}\n## Dunder methods\n\nYou can list all of an objects properties and methods using `dir`:\n\n```{python}\ndir(my_list)\n```\n\nNotice that lots of these are methods have a name sandwiched between double underscores and for this reason are called _dunder methods_ (or _magic methods_, or just _special methods_). This is to indicate that they are not to be used by you, but by the Python interpreter to implement certain standard functions that apply to many different classes of objects. For instance, when you write `len(my_list)` to find the length of `my_list` Python is actually calling the dunder method `my_list.__len__` which does the job of actually finding the length.\n\n```{python}\nmy_list.__len__()\n```\n\nIn this way the same function (`len` in this case) can operate on many different objects, an example of what is called [polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)) in object oriented programming.\n\n:::\n\n## Arrays\n\nThe fundamental object in NumPy is the _Array_, which you can think of as a multidimensional version of a list. Let's start with two dimensions to demonstrate:\n\n```{python}\nimport numpy as np\nmy_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\n```\n\n```{python}\ntype(my_array)\n```\n\nArrays can be indexed, similar to lists\n\n```{python}\nprint(my_array[0], my_array[1], my_array[3][1])\n```\n\nbut – different from a ordinary list of lists – the last one can be much more pleasantly achieved with the syntax\n\n```{python}\nmy_array[3,1]\n```\n\nWe also have a generalization of the slice syntax \n\n```{python}\nmy_array[1:, 1:]\n```\n\nSlicing can be mixed with integer indexing\n\n```{python}\nmy_array[1:, 1]\n```\n\nNumPy offers all sorts of fancy indexing options for slicing and dicing your data: see the [documentation](https://numpy.org/doc/stable/user/basics.indexing.html) for details.\n\nA fundamental property of an array is its `shape`:\n\n```{python}\n# [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\nmy_array.shape\n```\n\nThe way to read off the shape of an array is as follows. To begin with you encounter a number of `[` corresponding to the rank of the array (two in the above example). You then scan over a number of entries that give the rightmost (innermost) dimension in the shape tuple before closing `]` (3 here). After a number of 1D arrays `[...]` equal to the next innermost dimension (4 here), we have another closing `]`, and so on.\n  \nIt's definitely something that will take a bit of time getting used to!\n\nNotice that slicing does not change the rank of the array\n\n```{python}\nmy_array[1:, 1:].shape\n```\n\nbut integer indexing does\n\n```{python}\nmy_array[1:, 1].shape\n```\n\nNumPy has lots of methods to create arrays with a given shape and populated in different ways:\n\n```{python}\na = np.zeros((2,2))\nprint(a)\n\nb = np.ones((2,2))\nprint(b)\n\nc = np.full((2,2), 5)\nprint(c)\n\nd = np.random.random((2,2)) # random numbers uniformly in [0.0, 1.0)\nprint(d)\n```\n\nA NumPy array has a `dtype` property that gives the datatype. If the array was created from data, this will be inferred\n\n```{python}\nmy_array.dtype\n```\n\nFunctions that construct arrays also have an optional argument to specify the datatype\n\n```{python}\nmy_float_array = np.array([1,2,3], dtype=np.float64)\nmy_float_array.dtype\n```\n\n\n## Mathematical operations with arrays\n\nNow here comes the payoff. On lists, multiplication by an integer concatentates multiple copies\n\n```{python}\n2 * [1, 2, 3]\n```\n\nwhich is sometimes useful. But in numerical applications what we really want is this\n\n```{python}\n2 * np.array([1, 2, 3])\n```\n\nThis illustrates a general feature of NumPy that __all mathematical operations are performed elementwise on arrays!__\n\n```{python}\nprint(np.array([1, 2, 3]) + np.array([4, 5, 6]))\nprint(np.array([1, 2, 3])**2)\nprint(np.sqrt(np.array([1, 2, 3])))\n```\n\nThis avoids the need to write nested loops to perform some operation on each element of some multidimensional data. Of course, the loops are still there, it's just that NumPy handles them in highly optimized C rather than Python. Code which operates in this way – rather than with explicit loops – is often described as _vectorized_, and in NumPy-speak vectorized functions are called _ufuncs_, short for _universal functions_ (you can [write your own](https://numpy.org/doc/stable/reference/ufuncs.html) if you need to). As a basic principle you should _never_ use a Python loop to access your data in NumPy code. Loops may appear at a high level in stepping through time steps in a simulation, for example.\n\n### Broadcasting\n\nVectorization is even more versatile than the above examples might suggest. _Broadcasting_ is a powerful protocol that allows us to combine arrays of different shapes. Thus we can add a number to an array\n\n```{python}\nnp.array([1, 2, 3]) + 2.3\n```\n\nMore generally, elementwise operations can be performed on two arrays of the same rank if in each dimension the sizes either match or one array has size 1.\n\n```{python}\n# These have shape (2, 3) and (1, 3)\nnp.array([[1, 2, 3], [4, 5, 6]]) + np.array([[4, 3, 2]])\n```\n\nIn fact, we can simplify this last example\n\n```{python}\n# These have shape (2, 3) and (3,)\nnp.array([[1, 2, 3], [4, 5, 6]]) + np.array([4, 3, 2])\n```\n\nBroadcasting two arrays follows these rules:\n\n1. If the arrays do not have the same rank, prepend the shape of the lower rank array with 1s until both shapes have the same length.\n\n2. The two arrays are said to be compatible in a dimension if they have the same size in the dimension, or if one of the arrays has size 1 in that dimension.\n\n3. The arrays can be broadcast together if they are compatible in all dimensions.\nAfter broadcasting, each array behaves as if it had shape equal to the elementwise maximum of shapes of the two input arrays.\n\n4. In any dimension where one array had size 1 and the other array had size greater than 1, the first array behaves as if it were copied along that dimension.\n\n[The documentation](https://numpy.org/doc/stable/user/basics.broadcasting.html) has more detail.\n\n### Example: playing with images\n\nNice example of a 2D array?\n\nTODO\n\n## Plotting with Matplotlib\n\nThere are various specialized Python plotting libraries but the entry-level option is the catchily named [Matplotlib](https://matplotlib.org/). The `pyplot` module provides a plotting system that is similar to MATLAB (I'm told)\n\n```{python}\nimport matplotlib.pyplot as plt\n```\n\nHere's a simple example of the `plot` function, used to plot 2D data\n\n```{python}\n# Compute the x and y coordinates for points on a sine curve\nx = np.arange(0, 3 * np.pi, 0.1)\ny = np.sin(x)\n\n# Plot the points using matplotlib\nplt.plot(x, y)\nplt.show()\n```\n\n__Note__: you must call plt.show() to make graphics appear. Here's a fancier example with some labelling\n\n```{python}\n# Compute the x and y coordinates for points on sine and cosine curves\nx = np.arange(0, 3 * np.pi, 0.1)\ny_sin = np.sin(x)\ny_cos = np.cos(x)\n\n# Plot the points using matplotlib\nplt.plot(x, y_sin)\nplt.plot(x, y_cos)\nplt.xlabel('x axis label')\nplt.ylabel('y axis label')\nplt.title('Sine and Cosine')\nplt.legend(['Sine', 'Cosine'])\nplt.show()\n```\n\nOften you'll want to make several related plots and present them together, which can be achieved using the `subplot` function\n\n```{python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Compute the x and y coordinates for points on sine and cosine curves\nx = np.arange(0, 3 * np.pi, 0.1)\ny_sin = np.sin(x)\ny_cos = np.cos(x)\n\n# Set up a subplot grid that has height 2 and width 1,\n# and set the first such subplot as active.\nplt.subplot(2, 1, 1)\n\n# Make the first plot\nplt.plot(x, y_sin)\nplt.title('Sine')\n\n# Set the second subplot as active, and make the second plot.\nplt.subplot(2, 1, 2)\nplt.plot(x, y_cos)\nplt.title('Cosine')\n\n# Show the figure.\nplt.show()\n```\n\n\n## Saving and loading data\n\nIn the course of your work you are likely to produce, as well as consume lots of data. While it's good practice to keep notebooks capable of reproducing any of your analyses, this could be time consuming and resource heavy for larger computations. Thus at some point you'll probably want to save and load data. For example, after saving the data of a large scale simulation you'd like to load it and perform some analysis.\n\nNumPy comes with its own [save](https://numpy.org/doc/stable/reference/generated/numpy.save.html) and [load](https://numpy.org/doc/stable/reference/generated/numpy.load.html) functions and associated binary format `.npy`. The benefit of using these is that after loading you get back a NumPy array ready to be used.\n\nA related function [savez](https://numpy.org/doc/stable/reference/generated/numpy.savez.html) allows several arrays to be saved and then loaded as a dictionary-like object.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"numpy.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.280","bibliography":["references.bib"],"theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"numpy.pdf"},"language":{},"metadata":{"block-headings":true,"bibliography":["references.bib"],"documentclass":"scrreprt"},"extensions":{"book":{}}}}}