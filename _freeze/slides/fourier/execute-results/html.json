{
  "hash": "88b4f6cbc9ed111b8b62245d8a91d2b7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nnumber-sections: false\nformat:\n  revealjs:\n    theme: [default, reveal_custom.scss]\n    slide-number: true\n    hash: true\n    center: true\n    auto-stretch: false\n    html-math-method: mathjax\n    preview-links: true\n---\n\n# Fast Fourier transform\n\n- Fourier transforms are useful\n\n- Can we calculate them _efficiently_?\n\n## The discrete Fourier transform\n\n- Change of basis in a finite dimensional space\n\n- Maps signal sampled at $N$ regularly spaced time points to representation at $N$ frequency points\n$$\nF_n = \\sum_{j=0}^{N-1} f_j e^{-i\\eta_n j},\\qquad \\eta_n\\equiv \\frac{2\\pi n}{N}\n$$ \n\n- $F_n$ contain same information as $f_j$, and $f_j$ can be recovered completely by inverting operation\n- Note that $e^{-i\\eta_n j}=e^{-i\\eta_{n-N} j}$ so we can extend definition $F_n=F_{N-n}$\n\n---\n\n- Key to inverting \n$$\n\\sum_{n=0}^{N-1} e^{i\\eta_n j} = \\begin{cases}\n0 & j\\neq 0 \\mod N\\\\\nN & j = 0 \\mod N.\n\\end{cases} \n$$\n\n> One way to show this is via\n>$$\n>z^N-1 = (z-1)(1 + z + z^2 +\\cdots z^{N-1})\n>$$\n>Can you fill in the argument? __Note__: $e^{i\\eta_n}$ are $N$th roots of 1\n\n---\n\n- Inverting gives\n$$\nf_j = \\frac{1}{N}\\sum_{n=0}^{N-1}  F_n e^{i\\eta_n j}.\n$$\n\n- \"Democratic\" definition would have $1/\\sqrt{N}$ in both definitions\n\n - DFT then change of basis to orthonormal basis $e^{(n)}_j = \\frac{e^{i\\eta_n j}}{\\sqrt{N}}$\n \n - Both DFT and its inverse then unitary \n\n---\n\n- Fourier transforms with complex exponentials have positive and negative frequencies\n\n- Here $\\eta_n$ values for $n$ close to $N-1$ are the negative frequencies since $e^{-i\\eta_n j}=e^{2\\pi ij -i\\eta_n j}=e^{i\\eta_{N - n}j}$\n\n- Several limits to consider...\n\n## $N\\to\\infty$ limit\n\n- $\\eta_n$ values become dense in range $(-\\pi,\\pi]$, with separation $\\Delta \\eta = 2\\pi/N$\n\n- Replace sum in IDFT integral according to:\n$$\n\\sum_{n=0}^{N-1} \\left(\\cdots\\right) \\xrightarrow{N\\to\\infty} N \\int_{0}^{2\\pi} \\frac{d\\eta}{2\\pi}\\left(\\cdots\\right)\n$$\n$$\nf_j = \\int_{0}^{2\\pi} \\frac{d\\eta}{2\\pi}\\,F(\\eta) e^{i\\eta j}\n$$\n\n## $N\\to\\infty$ with $f_j = f(jL/N)$\n\n- $N\\to\\infty$ limit samples $f(x)$ ever more finely in range (0,L]\n\n- Now DFT becomes an integral\n$$\n\\hat f(k) \\equiv \\int_0^L f(x) e^{-ik_n x}\\,dx,\n$$\nwhere $k_n =2\\pi n/L$. Note that $k_n x = \\eta_n j$. \n$$\n\\begin{align}\n\\hat f_k &= \\int_0^L f(x) e^{-ik_n x}\\,dx\\nonumber\\\\\nf(x) &= \\frac{1}{L}\\sum_k \\hat f_k e^{ik_n x}\n\\end{align} \n$$\n\n---\n\n$$\n\\begin{align}\n\\hat f_k &= \\int_0^L f(x) e^{-ik_n x}\\,dx\\nonumber\\\\\nf(x) &= \\frac{1}{L}\\sum_k \\hat f_k e^{ik_n x}\n\\end{align} \n$$\n\n- Now $\\hat f_k$ has extra dimension of distance (on account of integral), which gets removed by the $1/L$ in inverse\n$$\n \\frac{1}{L}\\sum_k e^{ik x} = \\delta_L(x)\n$$\n$\\delta_L(x)$ is an $L$-periodic version of the $\\delta$-function.\n\n## $L\\to\\infty$\n\n- Finally __Fourier transform__, where we take $L\\to\\infty$, so that inverse transform becomes an integral too\n$$\n\\begin{align}\n\\hat{f}(k) & = \\int_{-\\infty}^\\infty f(x) e^{-ik_n x}\\,dx\\nonumber\\\\\nf(x) &= \\int_{-\\infty}^\\infty \\hat f(k) e^{ik_n x}\\,\\frac{dk}{2\\pi}\n\\label{coll_FTTrans}\n\\end{align}\n$$\n\n## Some important properties {#sec-properties}\n\n- Some properties of DFT (and all of the above)\n\n1. If $f_j$ is real then $F_n = \\left[F_{-n}\\right]^*$.\n\n2. If $f_j$ is even (odd), $F_n$ is even (odd).\n\n3. (Ergo) if $f_j$ is real and even, so is $F_n$.\n\n## Higher dimensions\n\n- Generalizes to higher dimensions straightforwardly\n\n- If data lives $d$ dimensions with $N_i$ datapoints along dimension $i=1,\\dots d$\n$$\nF_{\\mathbf{n}} = \\sum_{\\mathbf{n}} f_\\mathbf{j}e^{-i \\boldsymbol{\\eta}_\\mathbf{n}\\cdot \\mathbf{j}}\n$$\n$\\mathbf{j}=(j_1,\\ldots j_{d})$ with $j_i = 0,\\ldots N_i - 1$ and $\\boldsymbol{\\eta}_\\mathbf{n} = 2\\pi (n_1 / N_1, \\ldots n_d/ N_d)$ $n_i = 0,\\ldots N_i - 1$ \n\n# Fast Fourier transform\n\n$$\nF_n = \\sum_{j=0}^{N-1} f_j e^{-i\\eta_n j}\n$$ \n\n- What is _complexity_ of computing the Fourier transform? \n\n- DFT is _matrix-vector multiplication_\n$$\n\\mathbf{F} = Q \\cdot \\mathbf{f}.\n$$\n where matrix has elements $Q_{n j}\\equiv e^{-i\\eta_n j}$\n\n- Naively, complexity is $O(N^2)$\n\n---\n\n- Can do a _lot_ better than this, because of structure of $Q$!\n\n- Divide and conquer pattern: break problem up into two sub-problems\n\n$$\nf^{\\text{e}}_j = f_{2j}\\qquad f^{\\text{o}}_j = f_{2j+1},\\qquad j=0,\\ldots N/2 - 1.\n$$\n\n- __Key idea:__ we are going to express DFT $F_n$ in terms of DFT of $f^\\text{e}_j$ and $f^\\text{o}_j$\n\n---\n\n- Write $\\omega_N \\equiv e^{2\\pi i/N}$, so that $e^{i\\eta_n j}=\\omega_N^{nj}$ and DFT is\n\n$$\nF_n = \\sum_{j=0}^{N-1} f_j \\omega_N^{-nj}\n$$\n$$\n\\begin{align}\nF_n &= \\sum_{j=0}^{N-1} \\omega_N^{-nj} f_j \\\\\n&=\\sum_{j=0}^{N/2-1} \\left[\\omega_N^{-2nj} f^{\\text{e}}_j + \\omega_N^{-n(2j+1)}f^{\\text{o}}_j\\right]\\\\\n&=\\sum_{j=0}^{N/2-1} \\left[\\omega_{N/2}^{-nj} f^{\\text{e}}_j + \\omega_N^{-n}\\omega_{N/2}^{-nj}f^{\\text{o}}_j\\right]\n\\end{align}\n$$\n\n---\n\n$$\nF_n =\\sum_{j=0}^{N/2-1} \\left[\\omega_{N/2}^{-nj} f^{\\text{e}}_j + \\omega_N^{-n}\\omega_{N/2}^{-nj}f^{\\text{o}}_j\\right]\n$$\n\n- Already looking like sum of two DFTs of size $N/2$\n\n- Write $n$ as\n$$\nn = (N/2)n_0 + n'\n$$\nwhere $n_0=0,1$ and $n'=0,\\ldots N/2 - 1$. \n\n- If $n$ a power of 2, $n_0$ is most significant bit of $n$ when written in binary and $n'$ are remaining bits\n\n---\n\n$$\nn = (N/2)n_0 + n'\n$$\n\n- Since $\\omega_{N/2}^{-jn}=\\omega_{N/2}^{-jn'}$ we have\n\n$$\n\\begin{align}\nF_n &= \\sum_{j=0}^{N/2-1} \\left[\\omega_{N/2}^{-nj} f^{\\text{e}}_j + \\omega_N^{-n}\\omega_{N/2}^{-nj}f^{\\text{o}}_j\\right]\\\\\n&=\\sum_{j=0}^{N/2-1} \\left[\\omega_{N/2}^{-n'j} f^{\\text{e}}_j + (-1)^{n_0}\\omega_N^{-n'} \\omega_{N/2}^{-n'j}f^{\\text{o}}_j\\right]\\\\\n&= F^\\text{e}_{n'} + (-1)^{n_0}\\omega_N^{-n'} F^\\text{o}_{n'}\n\\end{align}\n$$\n\n---\n\n$$\nF_n = F^\\text{e}_{n'} + (-1)^{n_0}\\omega_N^{-n'} F^\\text{o}_{n'}\n$$\n\n- If $N$ a power of 2 can repeat process until we get length 1\n\n![Butterfly diagram for the FFT Source:[Wikipedia](https://en.wikipedia.org/wiki/Fast_Fourier_transform)](../assets/FFT-butterfly.png){width=45%}\n\n---\n\n## Complexity\n\n- Clear that FFT is going to beat the naive approach\n\n- $T(N)$ is steps required to compute DFT for size $N$ input\n\n- Calculating $F^\\text{e}_{n'}$ and $F^\\text{0}_{n'}$ takes time $2T(N/2)$\n\n- Combining to evaluate $F_n$ is a further $N$ steps, so \n\n$$\nT(N) = 2T(N/2) +\\Theta(N)\n$$\n\n- This implies $T(N)=\\Theta(N\\log N)$\n\n---\n\n- What if $N$ isn't a power of 2?\n\n- Use divide and conquer strategy for any other factor $p$ of $N$\n\n- If largest prime factor of $N$ is bounded i.e. doesn't grow with $N$ this still yields $T(N)=\\Theta(N\\log N)$\n\n- If $N$ is prime you have to use [something else](https://en.wikipedia.org/wiki/Rader%27s_FFT_algorithm)\n\n- Best to ensure $N$ _is_ a power of two e.g. by choosing size of simulation appropriately or padding data with zeros\n\n## History\n\n- Modern invention of FFT is credited to @cooley1965algorithm. First to discuss complexity\n\n- Divide and conquer approach anticipated in radio astronomy by [David Wheeler](https://en.wikipedia.org/wiki/David_Wheeler_(computer_scientist)) in Cambridge (see @ryle1975radio) and @danielson1942some, for applications in crystallography\n\n- OG is [Carl Friedrich Gauss](https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss) in 1805 (predating even Fourier) in his astronomical studies\n\n- See @cooley1967historical for more on historical background\n\n## FFT in Python\n\n- FFT available in both NumPy (in the [`numpy.fft`](https://numpy.org/doc/stable/reference/routines.fft.html#module-numpy.fft) module) and SciPy (in [`scipy.fft`](https://docs.scipy.org/doc/scipy/reference/fft.html#module-scipy.fft)), with a more comprehensive set of functions\n\n- Our definitions are the defaults used in these modules (but always check conventions!)\n\n---\n\n- Several helper functions available to make your life easier:\n\n    1. `np.fft.fftfreq(n, d)`, which returns the _frequencies_ (not the angular frequencies) for input size $n$ and sample spacing $d$.\n    2. `np.fft.fftshift(A)` shifts data so that the zero frequency is in the centre.\n    3. `np.fft.ifftshift(A)` inverts this.\n\n## Simple example\n\n- Signal consisting of two sinusoids at 12 Hz and 34 Hz:\n\n::: {#e3a98ac3 .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n![](fourier_files/figure-revealjs/cell-2-output-1.png){width=805 height=429}\n:::\n:::\n\n\n---\n\n- Take FFT and plot vs array index\n\n::: {#2b2a167e .cell execution_count=2}\n``` {.python .cell-code}\nY=np.fft.fft(y)\nplt.plot(abs(Y))\n```\n\n::: {.cell-output .cell-output-display}\n![](fourier_files/figure-revealjs/cell-3-output-1.png){width=798 height=411}\n:::\n:::\n\n\n---\n\n- Or against real frequency (sample spacing of $dt=0.01$)\n\n::: {#1d6fe0d0 .cell execution_count=3}\n``` {.python .cell-code}\nf=np.fft.fftfreq(fftsize, dt)\n# Reordering makes a tidier plot...\nY=np.fft.fftshift(Y)\nf=np.fft.fftshift(f)\nplt.plot(f, abs(Y))\nplt.xlabel(\"Frequency / Hz\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](fourier_files/figure-revealjs/cell-4-output-1.png){width=798 height=429}\n:::\n:::\n\n\n---\n\n- Fourier transform of real valued data has property $F_n = \\left[F_{-n}\\right]^*$:\n\n::: {#92b50eb0 .cell execution_count=4}\n\n::: {.cell-output .cell-output-display}\n![](fourier_files/figure-revealjs/cell-5-output-1.png){width=819 height=429}\n:::\n:::\n\n\n## Windowing\n\n- Signal a pair of sinusoids, but FFT _not_ just $\\delta$-functions\n\n::: {#f31ade08 .cell execution_count=5}\n\n::: {.cell-output .cell-output-display}\n![](fourier_files/figure-revealjs/cell-6-output-1.png){width=828 height=429}\n:::\n:::\n\n\n- Because data is of _finite length_ \n\n---\n\n- _Windowing_ causes FFT to be non-zero outside the frequencies present in the signal: [spectral leakage](https://en.wikipedia.org/wiki/Spectral_leakage)\n\n- Sharp window means that FFT is effectively convolved with FT of top hat i.e. a sinc function\n\n- If window happens to contain a whole number of wavelengths of the signals present, spectral leakage does not occur\n\n---\n\n- Chose different [window functions](https://en.wikipedia.org/wiki/Window_function) e.g. with smooth edges\n\n - Rectangular / top hat window has _low dynamic range_: bad at distinguishing contributions of different amplitude even when their frequencies differ\n \n - Leakage from large peak may obscure smaller ones\n \n - It has _high resolution_: good at resolving peaks of similar amplitude that are close in frequency\n \n - Usually several options (Hamming, Tukey (him again), etc.) when using library functions that perform spectral analysis\n\n---\n\n![Importance of windowing LIGO data, from @abbott2020guide. Without appropriate windowing, entire power spectrum is dominated by spectral leakage](../assets/ligo-window.png){width=80%}\n\n# Applications of FFT\n\n- Mindboggling number of applications from signal processing in experimental data, audio and video signals, to numerical simulation\n\n- We'll look at two examples...\n\n## Signal processing\n\n- Time series data from LIGO and Virgo experiments on [gravitational wave detection](https://en.wikipedia.org/wiki/First_observation_of_gravitational_waves) that led to the 2017 Nobel prize in physics\n\n- See @abbott2020guide for details, as well as [accompanying notebook](https://github.com/losc-tutorial/Data_Guide/blob/master/Guide_Notebook.ipynb) that describes how analysis is performed in Python\n\n---\n\n![Stages in analysis of LIGO strain data,from @abbott2020guide. Note scale on $y$-axis!](../assets/ligo-stages.png){width=60%}\n\n---\n\n- Uncovering the signal in the raw data involves a number of processing steps designed to eliminate noise, mostly carried out in Fourier domain\n\n- Guiding principle is that the noise is _stationary_ — described by a random process that does not change in time — while signal is _transient_\n\n- This idea can be used to reduce noise in the data even though low frequency noise completely dominates the raw measurement (top panel)\n\n---\n\n- First step is windowing to reduce spectral leakage\n\n- Next, data is _whitened_: Fourier spectrum is normalized by spectral density\n$$\n\\tilde d(f)\\longrightarrow \\frac{\\tilde d(f)}{S_n^{1/2}(f)}\n$$\n\n- Idea is to prevent high amplitude noise in certain parts of the spectrum from swamping the signal\n\n- After this step (third panel, red trace), the low frequency noise has been greatly reduced\n\n---\n\n- Finally, filter with a pass band [35 Hz, 350 Hz], removing low frequency seismic noise and high frequency (quantum) noise from detector\n\n- Filtering is Fourier analog of windowing\n\n- At this point, a transient is revealed in the data (bottom panel)\n\n---\n\n- Fit transient with a model that describes graviational wave physics\n\n- Important check is to analyze _residual_ — difference between data and model — and to check whether it is described by a stationary noise process \n\n- The phases of Fourier components should be random and uncorrelated, for example\n\n---\n\n![Residuals from the modelled signal, from @abbott2020guide](../assets/ligo-residuals.png){width=60%}\n\n\n## Partial differential equations\n\n- [Spectral methods](https://en.wikipedia.org/wiki/Spectral_method) exploit FFT as part of solver\n\n- Example: time-dependent Schrödinger equation\n\n$$\ni\\hbar \\frac{\\partial \\psi}{\\partial t} = -\\frac{\\hbar^2}{2m}\\nabla^2 \\psi + V(\\mathbf{r})\\psi\n$$\n\n---\n\nWhen potential is absent, solutions are superpositions of plane waves\n\n$$\n\\Psi_\\mathbf{k}(\\mathbf{r}, t) = \\exp\\left[-i\\frac{\\hbar^2 \\mathbf{k}^2 t}{2m} +i\\mathbf{k}\\cdot\\mathbf{r}\\right]\n$$ {#eq-momentum}\n\n- If KE absent, evolution would be \n\n$$\n\\Psi(\\mathbf{r}, t) = \\Psi(\\mathbf{r}, 0)\\exp\\left[-iV(\\mathbf{r})t/\\hbar\\right]\n$$ {#eq-position}\n\n- Idea behind [split-step method](https://en.wikipedia.org/wiki/Split-step_method) is that time evolution can be approximated by alternating @eq-momentum and @eq-position\n\n- @eq-momentum requires that we express the solution in terms of plane wave components... FFT!\n\n---\n\n- Write equation in operator form as\n\n$$\ni\\hbar \\frac{\\partial \\ket{\\psi}}{\\partial t} = H\\ket{\\psi} = (T+V)\\ket{\\psi}\n$$\n\n- Solution is $\\ket{\\psi(t)} = \\exp(-iHt/\\hbar)\\ket{\\psi}(0)$\n\n- Exponential of $A+B$ obeys [Lie product formula](https://en.wikipedia.org/wiki/Lie_product_formula)\n\n$$\ne^{A+B} = \\lim_{n\\to\\infty}\\left( e^{A/n}e^{B/n}\\right)^n.\n$$\n\n---\n\n- More precisely,\n$$\ne^{xA}e^{xB} = e^{x(A+B) + O(x^2)}.\n$$\n\n- More accurate approximation is Suzuki—Trotter formula\n\n$$\ne^{xA/2}e^{xB}e^{xA/2} = e^{x(A+B) + O(x^3)}\n$$\n\n---\n\n- Here's a simple 1D example:\n\n::: {#26c3806e .cell execution_count=6}\n``` {.python .cell-code}\ndef split_step_schrodinger(psi_0, dx, dt, V, N, x_0 = 0., k_0 = None, m = 1.0, non_linear = False):\n\n\tlen_x = psi_0.shape[0]\n\n\tx = x_0 + dx*np.arange(len_x)\n\n\tdk_x = (2*np.pi)/(len_x*dx)\n\tif k_0 == None:\n\t\tk_0 = -np.pi/dx\n\tk_x = k_0+dk_x*np.arange(len_x)\n\n\tpsi_x = np.zeros((len_x,N), dtype = np.complex128)\n\tpsi_k = np.zeros((len_x,N), dtype = np.complex128)\n\tpsi_mod_x = np.zeros((len_x), dtype = np.complex128)\n\tpsi_mod_k = np.zeros((len_x), dtype = np.complex128)\n\tpsi_x[:,0] = psi_0\n\n\tif not non_linear:\n\t\tV_n = V(x)\n\telse:\n\t\tV_n = V(x,psi_0)\n\n\tdef _compute_psi_mod(j):\n\t\treturn (dx/np.sqrt(2*np.pi))*psi_x[:,j]*np.exp(-1.0j*k_x[0]*x)\n\n\tdef _compute_psi(j):\n\t\tpsi_x[:,j] = (np.sqrt(2*np.pi)/dx)*psi_mod_x*np.exp(1.0j*k_x[0]*x)\n\t\tpsi_k[:,j] = psi_mod_k*np.exp(-1.0j*x[0]*dk_x*np.arange(len_x))\n\n\tdef _x_half_step(j,ft = True):\n\t\tif ft == True:\n\t\t\tpsi_mod_x[:] = np.fft.ifft(psi_mod_k[:])\n\t\tif non_linear:\n\t\t\tV_n[:] = V(x,psi_x[:,j])\n\t\tpsi_mod_x[:] = psi_mod_x[:]*np.exp(-1.0j*(dt/2.)*V_n)\t\n\n\tdef _k_full_step():\n\t\tpsi_mod_k[:] = np.fft.fft(psi_mod_x[:])\n\t\tpsi_mod_k[:] = psi_mod_k[:]*np.exp(-1.0j*k_x**2*dt/(2.*m))\t\t\n\n\tdef _main_loop():\n\t\tpsi_mod_x[:] = _compute_psi_mod(0)\n\n\t\tfor i in range(N-1):\n\t\t\t_x_half_step(i,ft = False)\n\t\t\t_k_full_step()\n\t\t\t_x_half_step(i)\n\t\t\t_compute_psi(i+1)\n\n\t_main_loop()\n\n\treturn psi_x,psi_k,k_x\n```\n:::\n\n\n---\n\n\n\n\n\n\n\n![Wavepacket colliding with a top hat barrier. Black line is the modulus, while red and blue are the real and imaginary parts.](../assets/gaussian-barrier.mp4)\n\n---\n\n",
    "supporting": [
      "fourier_files"
    ],
    "filters": [],
    "includes": {}
  }
}