{
  "hash": "68b795374e97dc932f4b0a704c88c701",
  "result": {
    "markdown": "---\nnumber-sections: false\nformat:\n  revealjs: \n    slide-number: true\n    hash: true\n    center: true\n    auto-stretch: false\n    html-math-method: mathjax\n    preview-links: true\n---\n\n# NumPy and friends\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n```\n:::\n\n\n---\n\n- [NumPy](https://numpy.org/) package is _the_ key building block of the Python scientific ecosystem.\n\n- __Assume that what you want to achieve _can_ be achieved in a highly optimised way within the existing framework__\n\n- Only resort to your own solution if this is not the case\n\n- Many resources for learning NumPy online (see links in notes)\n\n## Preamble: objects in Python\n\n- Everything in Python is an _object_\n\n- For example `[1,2,3]` is a `list`:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nmy_list = [1, 2, 3]\ntype(my_list)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nlist\n```\n:::\n:::\n\n\n- Object is container for _properties_ and _methods_ (functions associated with object), accessed with `.` syntax.\n\n- e.g. lists have `append` method:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nmy_list.append(\"boop\")\nmy_list\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[1, 2, 3, 'boop']\n```\n:::\n:::\n\n\n---\n\n- In IPython you can see all the available methods by hitting tab:\n\n![](../assets/tab-complete.gif)\n\n---\n\n- List all of an objects properties and methods using `dir`:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(dir(my_list))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\n```\n:::\n:::\n\n\n- Many are _dunder methods_ (or _magic methods_, or just _special methods_), to be used by Python interpreter to implement certain standard functions\n\n---\n\n- e.g. `len(my_list)` is actually calling `my_list.__len__` which does job of actually finding length.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nmy_list.__len__()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n4\n```\n:::\n:::\n\n\n- Example of [polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)) in object oriented programming\n\n## Arrays\n\n- Fundamental object in NumPy is _Array_ (or `ndarray`), multidimensional version of a `list`\n\n- In plain old Python a matrix would be a list of lists.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndata = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\n```\n:::\n\n\n-  `data[i]` represents each row:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndata[1]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n[4, 5, 6]\n```\n:::\n:::\n\n\n---\n\n- To multiply every element by a number I would do something like this:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfor row in data:\n    for j, _ in enumerate(row):\n        row[j] *= 2\ndata\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n[[2, 4, 6], [8, 10, 12], [14, 16, 18], [20, 22, 24]]\n```\n:::\n:::\n\n\n::: incremental\n-  ___Don't do this___\n- NumPy is made for tasks like this with _minimum code_ and _maximum efficiency_\n:::\n\n---\n\n- First create data as array\n\n- Numerous NumPy functions produce arrays\n\n- Simplest is [numpy.array](https://numpy.org/doc/stable/reference/generated/numpy.array.html#numpy.array): takes data in \"Pythonic\" list-of-lists(-of-lists-of... etc.) form and produces `ndarray`\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nmy_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\ntype(my_array)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nnumpy.ndarray\n```\n:::\n:::\n\n\n---\n\n- Multiply array by number? Easy!\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n2 * my_array\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\narray([[ 2,  4,  6],\n       [ 8, 10, 12],\n       [14, 16, 18],\n       [20, 22, 24]])\n```\n:::\n:::\n\n\n- It even prints nicely\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nprint(my_array)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 1  2  3]\n [ 4  5  6]\n [ 7  8  9]\n [10 11 12]]\n```\n:::\n:::\n\n\n## Indexing\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nmy_array\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 7,  8,  9],\n       [10, 11, 12]])\n```\n:::\n:::\n\n\n- Arrays can be indexed, similar to lists\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nprint(my_array[0], my_array[1], my_array[3][1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3] [4 5 6] 11\n```\n:::\n:::\n\n\n- Better syntax for the last one\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nmy_array[3,1]\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n11\n```\n:::\n:::\n\n\n---\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nmy_array\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 7,  8,  9],\n       [10, 11, 12]])\n```\n:::\n:::\n\n\n- Also have a generalization of the _slice syntax \n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nmy_array[1:, 1:]\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\narray([[ 5,  6],\n       [ 8,  9],\n       [11, 12]])\n```\n:::\n:::\n\n\n- Slicing can be mixed with integer indexing\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nmy_array[1:, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray([ 5,  8, 11])\n```\n:::\n:::\n\n\n---\n\n- NumPy has all sorts of fancy indexing options \n\n- Indexing with integer arrays, with boolean arrays, etc.\n\n- See the [documentation](https://numpy.org/doc/stable/user/basics.indexing.html)\n\n## Shape\n\n- A fundamental property of an array is `shape`:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\nmy_array.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n(4, 3)\n```\n:::\n:::\n\n\n:::incremental\n- First a number of `[` corresponding to the __rank__ of the array (two in the above example)\n\n- Then number of entries giving rightmost (innermost) dimension in shape before closing `]` (3 here)\n\n- After a number of 1D arrays `[...]` equal to the next innermost dimension (4 here), we have another closing `]`, and so on\n  \n:::\n\n---\n\n- Slicing does not change the array rank\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nmy_array[1:, 1:].shape\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n(3, 2)\n```\n:::\n:::\n\n\n- Integer indexing does\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nmy_array[1:, 1].shape\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n(3,)\n```\n:::\n:::\n\n\n- __Note:__ `(3,)` is _tuple_ giving the shape while `(3)` is just the number 3 in brackets\n\n## Other ways to make arrays\n\n- NumPy has lots of methods to create arrays\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\na = np.zeros((2,2))\nprint(a)\nb = np.ones((2,2))\nprint(b)\nc = np.full((2,2), 5)\nprint(c)\nd = np.random.random((2,2)) # random numbers uniformly in [0.0, 1.0)\nprint(d)\neye = np.eye(2) # Identity matrix\nprint(eye)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0. 0.]\n [0. 0.]]\n[[1. 1.]\n [1. 1.]]\n[[5 5]\n [5 5]]\n[[0.88033089 0.21886361]\n [0.82283125 0.64978079]]\n[[1. 0.]\n [0. 1.]]\n```\n:::\n:::\n\n\n## Shape shifting\n\n- [numpy.reshape](https://numpy.org/doc/stable/reference/generated/numpy.reshape.html#numpy-reshape) to change the shape of an array\n\n- [numpy.expand_dims](https://numpy.org/doc/stable/reference/generated/numpy.expand_dims.html) to insert new axes of length one.\n\n- [numpy.squeeze](https://numpy.org/doc/stable/reference/generated/numpy.squeeze.html#numpy.squeeze) (the opposite) to remove new axes of length one.\n\n---\n\n- Example of `reshape`\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nmy_array.reshape(2, 2, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\narray([[[ 1,  2,  3],\n        [ 4,  5,  6]],\n\n       [[ 7,  8,  9],\n        [10, 11, 12]]])\n```\n:::\n:::\n\n\n- Only works if the shapes are compatible. Here it's OK because the original shape was $(4,3)$ and $4\\times 3 = 2\\times 2\\times 3$\n\n- If shapes aren't compatible, we'll get an error\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nmy_array.reshape(2, 3, 3)\n```\n\n::: {.cell-output .cell-output-error}\n```\nValueError: cannot reshape array of size 12 into shape (2,3,3)\n```\n:::\n:::\n\n\n## `dtype`\n\n- Arrays have `dtype` property that gives datatype\n\n- If array was created from data, this will be inferred\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nmy_array.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\ndtype('int64')\n```\n:::\n:::\n\n\n- Functions constructing arrays have optional `dtype`\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nmy_float_array = np.array([1,2,3], dtype=np.float64)\nmy_float_array.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\ndtype('float64')\n```\n:::\n:::\n\n\n- Importantly, complex numbers are supported\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nmy_float_array = np.array([1.1 + 2.3j,2.2,3.6])\nmy_float_array.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\ndtype('complex128')\n```\n:::\n:::\n\n\n## Examples of array-like data\n\n- Position, velocity, or acceleration of particle will be three dimensional vectors, so have shape `(3,)`\n\n- With $N$ particles could use a $3N$ dimensional vector\n\n- Better: an array of shape `(N,3)`. First index indexes particle number and second particle coordinate.\n\n- $N\\times M$ matrix has shape `(N,M)`\n\n- Riemann curvature tensor in General Relativity $R_{abcd}$ has shape `(4,4,4,4)`\n\n---\n\n- _Fields_ are functions of space and time e.g. the electric potential $\\phi(\\mathbf{r},t)$\n\n- Approximate these using a grid of space-time points $N_x\\times N_y \\times N_z\\times N_t$\n\n- Scalar field can be stored in an array of shape `(N_x,N_y,N_z,N_t)`\n\n- A vector field like $\\mathbf{E}(\\mathbf{r},t)$ would be `(N_x,N_y,N_z,N_t,3)`\n\n---\n\n- Very useful method to create a grid of coordinate values\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# Grid of x, y points\nnx, ny = 64, 64\nx = np.linspace(-2, 2, nx)\ny = np.linspace(-2, 2, ny)\nX, Y = np.meshgrid(x, y)\nX.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n(64, 64)\n```\n:::\n:::\n\n\n::: {.cell execution_count=28}\n\n::: {.cell-output .cell-output-display}\n![](numpy_files/figure-revealjs/cell-29-output-1.png){width=452 height=427}\n:::\n:::\n\n\n## Mathematical operations with arrays\n\n- On lists\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n2 * [1, 2, 3]\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n[1, 2, 3, 1, 2, 3]\n```\n:::\n:::\n\n\n- In numerical applications what we really want is\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n2 * np.array([1, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\narray([2, 4, 6])\n```\n:::\n:::\n\n\n---\n\n- General feature of NumPy: __all mathematical operations are performed elementwise on arrays!__\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nprint(np.array([1, 2, 3]) + np.array([4, 5, 6]))\nprint(np.array([1, 2, 3])**2)\nprint(np.sqrt(np.array([1, 2, 3])))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5 7 9]\n[1 4 9]\n[1.         1.41421356 1.73205081]\n```\n:::\n:::\n\n\n- Avoids need to write nested loops\n\n- Loops are still there, but written in C\n\n- This style of code is often described as _vectorized_\n\n- In NumPy-speak vectorized functions are called _ufuncs_\n\n- As a basic principle __never use a Python loop to access your data in NumPy code__\n\n## Broadcasting...\n\n- ...is a powerful protocol for combining arrays of different shapes, generalizing this kind of thing\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nnp.array([1, 2, 3]) + 2.3\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\narray([3.3, 4.3, 5.3])\n```\n:::\n:::\n\n\n---\n\n- Elementwise operations performed on two arrays of same rank if in each index sizes _either match or one array has size 1_\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# These have shape (2, 3) and (1, 3)\nnp.array([[1, 2, 3], [4, 5, 6]]) + np.array([[4, 3, 2]])\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\narray([[5, 5, 5],\n       [8, 8, 8]])\n```\n:::\n:::\n\n\n- We can simplify this last example\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# These have shape (2, 3) and (3,)\nnp.array([[1, 2, 3], [4, 5, 6]]) + np.array([4, 3, 2])\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\narray([[5, 5, 5],\n       [8, 8, 8]])\n```\n:::\n:::\n\n\n---\n\n- Recall example of an $N$-particle system described by a position array of shape `(N,3)`\n\n- If we want to shift the entire system by a vector, just add a vector of shape `(3,)` and broadcasting will ensure that this applied correctly to each particle.\n\n---\n\nBroadcasting two arrays follows these rules:\n\n1. If arrays do not have same rank, prepend shape of lower rank array with 1s until both shapes have same length\n\n---\n\n2. Two arrays are said to be _compatible_ in a dimension if they have same size in that dimension, or if one of the arrays has size 1 in that dimension\n\n---\n\n3. Arrays can be broadcast together if they are compatible in all dimensions.\nAfter broadcasting, each array behaves as if it had shape equal to the elementwise maximum of shapes of the two input arrays\n\n---\n\n4. In any dimension where one array had size 1 and the other array had size greater than 1, the first array behaves as if it were copied along that dimension\n\n:::incremental\n\n- [The documentation](https://numpy.org/doc/stable/user/basics.broadcasting.html) has more detail\n\n- Broadcasting takes some time to get used to but is immensely powerful!\n\n:::\n\n## Plotting with Matplotlib\n\n - Various specialized Python plotting libraries \n \n - \"entry-level\" option is [Matplotlib](https://matplotlib.org/)\n \n - `pyplot` module provides a plotting system that is similar to MATLAB (I'm told)\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n```\n:::\n\n\n- Probably the second most common import you will make!\n\n---\n\n- Here's a simple example of `plot` function\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Compute the x and y coordinates for points on a sine curve\nx = np.arange(0, 3 * np.pi, 0.1)\ny = np.sin(x)\n\n# Plot the points using matplotlib\nplt.plot(x, y)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](numpy_files/figure-revealjs/cell-37-output-1.png){width=813 height=404}\n:::\n:::\n\n\n- __Note__: you must call plt.show() to make graphics appear\n\n---\n\n- Fancier example with some labelling\n\n```python\n# Compute the x and y coordinates for points on sine and cosine curves\nx = np.arange(0, 3 * np.pi, 0.1)\ny_sin = np.sin(x)\ny_cos = np.cos(x)\n\n# Plot the points using matplotlib\nplt.plot(x, y_sin)\nplt.plot(x, y_cos)\nplt.xlabel('x axis label')\nplt.ylabel('y axis label')\nplt.title('Sine and Cosine')\nplt.legend(['Sine', 'Cosine'])\nplt.show()\n```\n\n---\n\n::: {.cell execution_count=37}\n\n::: {.cell-output .cell-output-display}\n![](numpy_files/figure-revealjs/cell-38-output-1.png){width=832 height=442}\n:::\n:::\n\n\n---\n\n- Often you'll want to make several related plots and present them together\n\n```python\nimport matplotlib.pyplot as plt\n\n# Compute the x and y coordinates for points on sine and cosine curves\nx = np.arange(0, 3 * np.pi, 0.1)\ny_sin = np.sin(x)\ny_cos = np.cos(x)\n\n# Set up a subplot grid that has height 2 and width 1,\n# and set the first such subplot as active.\nplt.subplot(2, 1, 1)\n\n# Make the first plot\nplt.plot(x, y_sin)\nplt.title('Sine')\n\n# Set the second subplot as active, and make the second plot.\nplt.subplot(2, 1, 2)\nplt.plot(x, y_cos)\nplt.title('Cosine')\n\n# Show the figure.\nplt.show()\n```\n\n---\n\n::: {.cell execution_count=38}\n\n::: {.cell-output .cell-output-display}\n![](numpy_files/figure-revealjs/cell-39-output-1.png){width=805 height=424}\n:::\n:::\n\n\n## Example: playing with images\n\n- Pixels in an image encoded as a triple of RGB values in the range [0,255] i.e. 8 bits of type `uint8` (the \"u\" is for \"unsigned\")\n\n- Tinting an image gives a nice example of broadcasting\n\n---\n\n```python\nimg = plt.imread('../assets/lucian.jpeg')\n\nimg_tinted = img * [1, 0.55, 1]\n\n# Show the original image\nplt.subplot(1, 2, 1)\nplt.imshow(img)\nplt.title(\"Lucian\")\n\n# Show the tinted image\nplt.subplot(1, 2, 2)\nplt.title(\"Pink Panther\")\n# Having multiplied by floats, \n# we must cast the image to uint8 before displaying it.\nplt.imshow(np.uint8(img_tinted))\n\nplt.show()\nimg.shape, img.dtype\n```\n\n---\n\n::: {.cell execution_count=39}\n\n::: {.cell-output .cell-output-display}\n![](numpy_files/figure-revealjs/cell-40-output-1.png){width=755 height=424}\n:::\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n((4032, 3024, 3), dtype('uint8'))\n```\n:::\n:::\n\n\nThis is a standard 12 megapixel image\n\n## Saving and loading data\n\n- At some point you'll probably want to save and load data\n\n- NumPy comes with its own [save](https://numpy.org/doc/stable/reference/generated/numpy.save.html) and [load](https://numpy.org/doc/stable/reference/generated/numpy.load.html) functions and associated binary format `.npy`\n\n- The benefit of using these is that after loading you get back a NumPy array ready to be used\n\n---\n\n- A related function [savez](https://numpy.org/doc/stable/reference/generated/numpy.savez.html) allows several arrays to be saved and then loaded as a dictionary-like object.\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\nrandom_matrix_1 = np.random.rand(4, 4)\nrandom_matrix_2 = np.random.rand(4, 4)\nnp.savez(\"../assets/my-matrices\", first_matrix=random_matrix_1, second_matrix=random_matrix_2)\n%ls ../assets\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfibonacci.png     ising.js          metropolis.png    tab-complete.png\r\nhard-spheres.png  ising.py          my-matrices.npz\r\nia-question.png   lucian.jpeg       tab-complete.gif\r\n```\n:::\n:::\n\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nmy_matrix_file = np.load(\"../assets/my-matrices.npz\")\nmy_matrix_file['first_matrix']\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\narray([[0.43303463, 0.46625546, 0.75395349, 0.69456282],\n       [0.5452065 , 0.15507252, 0.87227907, 0.93961307],\n       [0.10746136, 0.52692358, 0.0624021 , 0.21338092],\n       [0.62688037, 0.14867568, 0.04505824, 0.19230437]])\n```\n:::\n:::\n\n\n",
    "supporting": [
      "numpy_files"
    ],
    "filters": [],
    "includes": {}
  }
}