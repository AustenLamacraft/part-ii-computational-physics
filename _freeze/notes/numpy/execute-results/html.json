{
  "hash": "89cb403bb864fe5a67227f3a6ae64935",
  "result": {
    "markdown": "---\ntitle: NumPy and friends\n---\n\nThe [NumPy](https://numpy.org/) package is _the_ key building block of the Python scientific ecosystem.\n\nIn this chapter we introduce a few of the key concepts. You should refer to the [documentation](https://numpy.org/doc/stable/user/index.html) for details. As with any mature software ecosystem, you should first __assume that what you want to achieve _can_ be achieved in a highly optimised way within the existing framework__, and only resort to creating your own solution if and when you satisfy yourself that this is not the case.\n\nThere are a huge number of resources for learning NumPy online. Here are a couple of good ones:\n\n - [NumPy: the absolute basics for beginners](https://numpy.org/doc/stable/user/absolute_beginners.html) from the NumPy documentation is pretty great. \n \n - [This tutorial](https://cs231n.github.io/python-numpy-tutorial/) from a machine learning course at Stanford is also particularly nice and compact.\n\n# Preamble: objects in Python\n\nEverything in Python is an _object_. For example `[1,2,3]` is a `list`:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nmy_list = [1, 2, 3]\ntype(my_list)\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\nlist\n```\n:::\n:::\n\n\nYou can think of an object as a container for _properties_ and _methods_, the latter being functions associated with the object. Properties and methods are accessed with the `.` syntax. For example, lists have the `append` method, which adds an element to the end of the list:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nmy_list.append(\"boop\")\nmy_list\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n[1, 2, 3, 'boop']\n```\n:::\n:::\n\n\nWith IPython you can see all the available methods by hitting tab:\n\n![](assets/tab-complete.gif)\n\n::: {.callout-tip collapse=\"true\"}\n# Dunder methods\n\nYou can list all of an objects properties and methods using `dir`:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndir(my_list)\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\n['__add__',\n '__class__',\n '__class_getitem__',\n '__contains__',\n '__delattr__',\n '__delitem__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getitem__',\n '__gt__',\n '__hash__',\n '__iadd__',\n '__imul__',\n '__init__',\n '__init_subclass__',\n '__iter__',\n '__le__',\n '__len__',\n '__lt__',\n '__mul__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__reversed__',\n '__rmul__',\n '__setattr__',\n '__setitem__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n 'append',\n 'clear',\n 'copy',\n 'count',\n 'extend',\n 'index',\n 'insert',\n 'pop',\n 'remove',\n 'reverse',\n 'sort']\n```\n:::\n:::\n\n\nNotice that lots of these are methods have a name sandwiched between double underscores and for this reason are called _dunder methods_ (or _magic methods_, or just _special methods_). This is to indicate that they are not to be used by you, but by the Python interpreter to implement certain standard functions that apply to many different classes of objects. For instance, when you write `len(my_list)` to find the length of `my_list` Python is actually calling the dunder method `my_list.__len__` which does the job of actually finding the length.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nmy_list.__len__()\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n4\n```\n:::\n:::\n\n\nIn this way the same function (`len` in this case) can operate on many different objects, an example of what is called [polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)) in object oriented programming.\n\n:::\n\n# Arrays\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\n```\n:::\n\n\nThe fundamental object in NumPy is the _Array_ (or `ndarray`), which you can think of as a multidimensional version of a list. If we were representing two dimensional data — or a matrix — in plain old Python you would use a list of lists.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndata = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\n```\n:::\n\n\nHere `data[i]` represents each row:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndata[1]\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\n[4, 5, 6]\n```\n:::\n:::\n\n\nIf I wanted to multiply every element by a number I would have to do something like this:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfor row in data:\n    for j, _ in enumerate(row):\n        row[j] *= 2\ndata\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\n[[2, 4, 6], [8, 10, 12], [14, 16, 18], [20, 22, 24]]\n```\n:::\n:::\n\n\nIf the details here are a bit unfamiliar don't worry. The point I want to emphasize is: _don't do this_. \n\nNumPy provides us with the tools to perform this kind of operation with minimum code and maximum efficiency. First we create our data as an array. There are numerous NumPy functions that produce arrays. The simplest is [numpy.array](https://numpy.org/doc/stable/reference/generated/numpy.array.html#numpy.array). It takes data in the \"Pythonic\" list-of-lists(-of-lists-of... etc.) form and produces the corresponding `ndarray`\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nmy_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\ntype(my_array)\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\nnumpy.ndarray\n```\n:::\n:::\n\n\nNow, how do we multiply the whole array by a number? Like this, of course\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n2 * my_array\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\narray([[ 2,  4,  6],\n       [ 8, 10, 12],\n       [14, 16, 18],\n       [20, 22, 24]])\n```\n:::\n:::\n\n\nIt even prints nicely\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nprint(my_array)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 1  2  3]\n [ 4  5  6]\n [ 7  8  9]\n [10 11 12]]\n```\n:::\n:::\n\n\nArrays can be indexed, similar to lists\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nprint(my_array[0], my_array[1], my_array[3][1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3] [4 5 6] 11\n```\n:::\n:::\n\n\nbut — different from a ordinary list of lists — the last one can be much more pleasantly achieved with the syntax\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nmy_array[3,1]\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\n11\n```\n:::\n:::\n\n\nWe also have a generalization of the slice syntax \n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nmy_array[1:, 1:]\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\narray([[ 5,  6],\n       [ 8,  9],\n       [11, 12]])\n```\n:::\n:::\n\n\nSlicing can be mixed with integer indexing\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nmy_array[1:, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\narray([ 5,  8, 11])\n```\n:::\n:::\n\n\nNumPy offers all sorts of fancy indexing options for slicing and dicing your data: see the [documentation](https://numpy.org/doc/stable/user/basics.indexing.html) for details.\n\nA fundamental property of an array is its `shape`:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\nmy_array.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=57}\n```\n(4, 3)\n```\n:::\n:::\n\n\nThe way to read off the shape of an array is as follows. To begin with you encounter a number of `[` corresponding to the rank of the array (two in the above example). You then scan over a number of entries that give the rightmost (innermost) dimension in the shape tuple before closing `]` (3 here). After a number of 1D arrays `[...]` equal to the next innermost dimension (4 here), we have another closing `]`, and so on.\n  \nIt's definitely something that will take a bit of time getting used to!\n\nNotice that slicing does not change the rank of the array\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nmy_array[1:, 1:].shape\n```\n\n::: {.cell-output .cell-output-display execution_count=58}\n```\n(3, 2)\n```\n:::\n:::\n\n\nbut integer indexing does\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nmy_array[1:, 1].shape\n```\n\n::: {.cell-output .cell-output-display execution_count=59}\n```\n(3,)\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n# What's with the comma?\n\nIt's to distinguish the tuple `(3,)` giving the shape from `(3)` which is just the number 3 in brackets\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ntype((3,))\n```\n\n::: {.cell-output .cell-output-display execution_count=60}\n```\ntuple\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ntype((3))\n```\n\n::: {.cell-output .cell-output-display execution_count=61}\n```\nint\n```\n:::\n:::\n\n\n:::\n\nIt wouldn't be very convenient if you always had to create your arrays from nested lists using `np.array`. Fortunately NumPy has lots of methods to create arrays with a given shape and populated in different ways:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\na = np.zeros((2,2))\nprint(a)\n\nb = np.ones((2,2))\nprint(b)\n\nc = np.full((2,2), 5)\nprint(c)\n\nd = np.random.random((2,2)) # random numbers uniformly in [0.0, 1.0)\nprint(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0. 0.]\n [0. 0.]]\n[[1. 1.]\n [1. 1.]]\n[[5 5]\n [5 5]]\n[[0.3042687  0.47611684]\n [0.05467208 0.53129742]]\n```\n:::\n:::\n\n\nThere are also lots of methods to change the shape of arrays, for example\n\n- [numpy.reshape](https://numpy.org/doc/stable/reference/generated/numpy.reshape.html#numpy-reshape) to change the shape of an array.\n\n- [numpy.expand_dims](https://numpy.org/doc/stable/reference/generated/numpy.expand_dims.html) to insert new axes of length one.\n\n- [numpy.squeeze](https://numpy.org/doc/stable/reference/generated/numpy.squeeze.html#numpy.squeeze) (the opposite) to remove new axes of length one.\n\nLet's see an example of the first one:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nmy_array.reshape(2, 2, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=63}\n```\narray([[[ 1,  2,  3],\n        [ 4,  5,  6]],\n\n       [[ 7,  8,  9],\n        [10, 11, 12]]])\n```\n:::\n:::\n\n\nReshaping only works if the shapes are compatible. In this case it's OK because the original shape was $(4,3)$ and $4\\times 3 = 2\\times 2\\times 3$. If the shapes aren't compatible, we'll get an error\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nmy_array.reshape(2, 3, 3)\n```\n\n::: {.cell-output .cell-output-error}\n```\nValueError: cannot reshape array of size 12 into shape (2,3,3)\n```\n:::\n:::\n\n\nA NumPy array has a `dtype` property that gives the datatype. If the array was created from data, this will be inferred\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nmy_array.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=65}\n```\ndtype('int64')\n```\n:::\n:::\n\n\nFunctions that construct arrays also have an optional argument to specify the datatype\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nmy_float_array = np.array([1,2,3], dtype=np.float64)\nmy_float_array.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=66}\n```\ndtype('float64')\n```\n:::\n:::\n\n\nImportantly, complex numbers are supported\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nmy_float_array = np.array([1.1 + 2.3j,2.2,3.6])\nmy_float_array.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=67}\n```\ndtype('complex128')\n```\n:::\n:::\n\n\n# Examples of array-like data\n\nIt's not hard to come up with examples of array-like data in physics. The position, velocity, or acceleration of a particle will be three dimensional vectors, so have shape `(3,)`. If we had $N$ particles you could either put them in a $3N$ dimensional vector, but for reasons that will become clear it would be better to store them in an array of shape `(N,3)`, so that the first index indexes the particle number and the second the particle coordinate.\n\nAn $N\\times M$ matrix has shape `(N,M)`. The Riemann curvature tensor in General Relativity $R_{abcd}$ has shape `(4,4,4,4)`. \n\nOften we deal with _fields_ which are functions of space and time e.g. the electric potential $\\phi(\\mathbf{r},t)$. On a computer we often approximate these using a grid of space-time points $N_x\\times N_y \\times N_z\\times N_t$. Thus the values of a scalar field could be stored in an array of shape `(N_x,N_y,N_z,N_t)`. If we had a vector field like $\\mathbf{E}(\\mathbf{r},t)$ this would be `(N_x,N_y,N_z,N_t,3)`. You get the idea.\n\nA very useful method to create a grid of coordinate values (at which you can evaluate a function, say) is as follows\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# Grid of x, y points\nnx, ny = 64, 64\nx = np.linspace(-2, 2, nx)\ny = np.linspace(-2, 2, ny)\nX, Y = np.meshgrid(x, y)\n```\n:::\n\n\n::: {.cell execution_count=28}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Dipole electric field\"}\n# Example from https://scipython.com/blog/visualizing-a-vector-field-with-matplotlib/\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\n\ndef E(q, r0, x, y):\n    \"\"\"Return the electric field vector E=(Ex,Ey) due to charge q at r0.\"\"\"\n    den = np.hypot(x-r0[0], y-r0[1])**3\n    return q * (x - r0[0]) / den, q * (y - r0[1]) / den\n\n# Dipole\ncharges = [(1, (1, 0)), (-1, (-1, 0))]\n\n# Electric field vector, E=(Ex, Ey), as separate components\nEx, Ey = np.zeros((ny, nx)), np.zeros((ny, nx))\nfor charge in charges:\n    ex, ey = E(*charge, x=X, y=Y)\n    Ex += ex\n    Ey += ey\n\nfig = plt.figure()\nax = fig.add_subplot(111)\n\n# Plot the streamlines with an appropriate arrow style\ncolor = 2 * np.log(np.hypot(Ex, Ey))\nax.streamplot(x, y, Ex, Ey, color=color, linewidth=1,\n              density=2, arrowstyle='->', arrowsize=1.5)\n\n# Add filled circles for the charges themselves\ncharge_colors = {True: '#aa0000', False: '#0000aa'}\nfor q, pos in charges:\n    ax.add_artist(Circle(pos, 0.05, color=charge_colors[q>0]))\n\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nax.set_xlim(-2,2)\nax.set_ylim(-2,2)\nax.set_aspect('equal')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](numpy_files/figure-html/cell-29-output-1.png){width=452 height=427}\n:::\n:::\n\n\n# Mathematical operations with arrays\n\nI've already hinted at the payoff from all of this. On lists, multiplication by an integer concatentates multiple copies\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n2 * [1, 2, 3]\n```\n\n::: {.cell-output .cell-output-display execution_count=70}\n```\n[1, 2, 3, 1, 2, 3]\n```\n:::\n:::\n\n\nwhich is sometimes useful. But in numerical applications what we really want is this\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n2 * np.array([1, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=71}\n```\narray([2, 4, 6])\n```\n:::\n:::\n\n\nThis illustrates a general feature of NumPy that __all mathematical operations are performed elementwise on arrays!__\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nprint(np.array([1, 2, 3]) + np.array([4, 5, 6]))\nprint(np.array([1, 2, 3])**2)\nprint(np.sqrt(np.array([1, 2, 3])))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5 7 9]\n[1 4 9]\n[1.         1.41421356 1.73205081]\n```\n:::\n:::\n\n\nThis avoids the need to write nested loops to perform some operation on each element of some multidimensional data. Of course, the loops are still there, it's just that NumPy handles them in highly optimized C rather than Python. Code which operates in this way – rather than with explicit loops – is often described as _vectorized_, and in NumPy-speak vectorized functions are called _ufuncs_, short for _universal functions_ (you can [write your own](https://numpy.org/doc/stable/reference/ufuncs.html) if you need to). As a basic principle you should _never_ use a Python loop to access your data in NumPy code. Loops may appear at a high level in stepping through time steps in a simulation, for example.\n\n# Broadcasting\n\nVectorization is even more versatile than the above examples might suggest. _Broadcasting_ is a powerful protocol that allows us to combine arrays of different shapes. Thus we can add a number to an array\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nnp.array([1, 2, 3]) + 2.3\n```\n\n::: {.cell-output .cell-output-display execution_count=73}\n```\narray([3.3, 4.3, 5.3])\n```\n:::\n:::\n\n\nMore generally, elementwise operations can be performed on two arrays of the same rank if in each dimension the sizes either match or one array has size 1.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# These have shape (2, 3) and (1, 3)\nnp.array([[1, 2, 3], [4, 5, 6]]) + np.array([[4, 3, 2]])\n```\n\n::: {.cell-output .cell-output-display execution_count=74}\n```\narray([[5, 5, 5],\n       [8, 8, 8]])\n```\n:::\n:::\n\n\nIn fact, we can simplify this last example\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# These have shape (2, 3) and (3,)\nnp.array([[1, 2, 3], [4, 5, 6]]) + np.array([4, 3, 2])\n```\n\n::: {.cell-output .cell-output-display execution_count=75}\n```\narray([[5, 5, 5],\n       [8, 8, 8]])\n```\n:::\n:::\n\n\nBroadcasting two arrays follows these rules:\n\n1. If the arrays do not have the same rank, prepend the shape of the lower rank array with 1s until both shapes have the same length.\n\n2. The two arrays are said to be compatible in a dimension if they have the same size in the dimension, or if one of the arrays has size 1 in that dimension.\n\n3. The arrays can be broadcast together if they are compatible in all dimensions.\nAfter broadcasting, each array behaves as if it had shape equal to the elementwise maximum of shapes of the two input arrays.\n\n4. In any dimension where one array had size 1 and the other array had size greater than 1, the first array behaves as if it were copied along that dimension.\n\n[The documentation](https://numpy.org/doc/stable/user/basics.broadcasting.html) has more detail.\n\nRecall our earlier example of an $N$-particle system described by a position array of shape `(N,3)`. If we want to shift the entire system by a vector, we can just add a vector of shape `(3,)` and broadcasting will ensure that this applied correctly to each particle.\n\n# Plotting with Matplotlib\n\nThere are various specialized Python plotting libraries but the entry-level option is the catchily named [Matplotlib](https://matplotlib.org/). The `pyplot` module provides a plotting system that is similar to MATLAB (I'm told)\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n```\n:::\n\n\nThis is probably the second most common import you will make. Here's a simple example of the `plot` function, used to plot 2D data\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Compute the x and y coordinates for points on a sine curve\nx = np.arange(0, 3 * np.pi, 0.1)\ny = np.sin(x)\n\n# Plot the points using matplotlib\nplt.plot(x, y)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](numpy_files/figure-html/cell-37-output-1.png){width=590 height=404}\n:::\n:::\n\n\n__Note__: you must call plt.show() to make graphics appear. Here's a fancier example with some labelling\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# Compute the x and y coordinates for points on sine and cosine curves\nx = np.arange(0, 3 * np.pi, 0.1)\ny_sin = np.sin(x)\ny_cos = np.cos(x)\n\n# Plot the points using matplotlib\nplt.plot(x, y_sin)\nplt.plot(x, y_cos)\nplt.xlabel('x axis label')\nplt.ylabel('y axis label')\nplt.title('Sine and Cosine')\nplt.legend(['Sine', 'Cosine'])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](numpy_files/figure-html/cell-38-output-1.png){width=609 height=442}\n:::\n:::\n\n\nOften you'll want to make several related plots and present them together, which can be achieved using the `subplot` function\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n# Compute the x and y coordinates for points on sine and cosine curves\nx = np.arange(0, 3 * np.pi, 0.1)\ny_sin = np.sin(x)\ny_cos = np.cos(x)\n\n# Set up a subplot grid that has height 2 and width 1,\n# and set the first such subplot as active.\nplt.subplot(2, 1, 1)\n\n# Make the first plot\nplt.plot(x, y_sin)\nplt.title('Sine')\n\n# Set the second subplot as active, and make the second plot.\nplt.subplot(2, 1, 2)\nplt.plot(x, y_cos)\nplt.title('Cosine')\n\n# Show the figure.\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](numpy_files/figure-html/cell-39-output-1.png){width=582 height=424}\n:::\n:::\n\n\n## Example: playing with images\n\nPixels in an image are encoded as a triple of RGB values in the range [0,255] i.e. 8 bits of type `uint8` (the \"u\" is for \"unsigned\"). Tinting an image gives us a nice example of broadcasting\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nimg = plt.imread('assets/lucian.jpeg')\n\nimg_tinted = img * [1, 0.55, 1]\n\n# Show the original image\nplt.subplot(1, 2, 1)\nplt.imshow(img)\nplt.title(\"Lucian\")\n\n# Show the tinted image\nplt.subplot(1, 2, 2)\nplt.title(\"Pink Panther\")\n# Having multiplied by floats, \n# we must cast the image to uint8 before displaying it.\nplt.imshow(np.uint8(img_tinted))\n\nplt.show()\nimg.shape, img.dtype\n```\n\n::: {.cell-output .cell-output-display}\n![](numpy_files/figure-html/cell-40-output-1.png){width=598 height=377}\n:::\n\n::: {.cell-output .cell-output-display execution_count=80}\n```\n((4032, 3024, 3), dtype('uint8'))\n```\n:::\n:::\n\n\nThis is a standard 12 megapixel image.\n\n# Saving and loading data\n\nIn the course of your work you are likely to produce, as well as consume lots of data. While it's good practice to keep notebooks capable of reproducing any of your analyses, this could be time consuming and resource heavy for larger computations. Thus at some point you'll probably want to save and load data. For example, after saving the data of a large scale simulation you'd like to load it and perform some analysis.\n\nNumPy comes with its own [save](https://numpy.org/doc/stable/reference/generated/numpy.save.html) and [load](https://numpy.org/doc/stable/reference/generated/numpy.load.html) functions and associated binary format `.npy`. The benefit of using these is that after loading you get back a NumPy array ready to be used.\n\nA related function [savez](https://numpy.org/doc/stable/reference/generated/numpy.savez.html) allows several arrays to be saved and then loaded as a dictionary-like object.\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\nrandom_matrix_1 = np.random.rand(4, 4)\nrandom_matrix_2 = np.random.rand(4, 4)\nnp.savez(\"assets/my-matrices\", first_matrix=random_matrix_1, second_matrix=random_matrix_2)\n%ls assets\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfibonacci.png     ising.js          metropolis.png    tab-complete.png\r\nhard-spheres.png  ising.py          my-matrices.npz\r\nia-question.png   lucian.jpeg       tab-complete.gif\r\n```\n:::\n:::\n\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nmy_matrix_file = np.load(\"assets/my-matrices.npz\")\nmy_matrix_file['first_matrix']\n```\n\n::: {.cell-output .cell-output-display execution_count=82}\n```\narray([[0.28263376, 0.48800925, 0.37393376, 0.68660859],\n       [0.71371632, 0.286268  , 0.23383825, 0.94389055],\n       [0.69422325, 0.62720148, 0.99779908, 0.14423974],\n       [0.14161904, 0.71973034, 0.90420564, 0.78931422]])\n```\n:::\n:::\n\n\n",
    "supporting": [
      "numpy_files"
    ],
    "filters": [],
    "includes": {}
  }
}