{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "number-sections: false\n",
        "format:\n",
        "  revealjs:\n",
        "    theme: [default, reveal_custom.scss]\n",
        "    slide-number: true\n",
        "    hash: true\n",
        "    center: true\n",
        "    auto-stretch: false\n",
        "    html-math-method: mathjax\n",
        "    preview-links: true\n",
        "---\n",
        "\n",
        "\n",
        "# Fast Fourier transform\n",
        "\n",
        "- Fourier transforms are useful\n",
        "\n",
        "- Can we calculate them _efficiently_?\n",
        "\n",
        "## No lectures next week!\n",
        "\n",
        "- Next lecture Monday 24th February\n",
        "- First exercise starts noon Friday 14th February\n",
        "\n",
        "\n",
        "## The discrete Fourier transform\n",
        "\n",
        "- Change of basis in a finite dimensional space\n",
        "\n",
        "- Mps signal sampled at $N$ regularly spaced time points to representation at $N$ frequency points\n",
        "$$\n",
        "F_n = \\sum_{j=0}^{N-1} f_j e^{-i\\eta_n j}\n",
        "$$ \n",
        "$\\eta_n\\equiv \\frac{2\\pi n}{N}$\n",
        "\n",
        "- $F_n$ contain same information as $f_j$, and $f_j$ can be recovered completely by inverting operation\n",
        "\n",
        "---\n",
        "\n",
        "- Key to inverting \n",
        "$$\n",
        "\\sum_{n=0}^{N-1} e^{i\\eta_n j} = \\begin{cases}\n",
        "0 & j\\neq 0 \\mod N\\\\\n",
        "N & j = 0 \\mod N.\n",
        "\\end{cases} \n",
        "$$\n",
        "\n",
        "> One way to show this is via\n",
        ">$$\n",
        ">z^N-1 = (z-1)(1 + z + z^2 +\\cdots z^{N-1})\n",
        ">$$\n",
        ">Can you fill in the argument? __Note__: $e^{i\\eta_n}$ are $N$th roots of 1\n",
        "\n",
        "---\n",
        "\n",
        "- Inverting gives\n",
        "$$\n",
        "f_j = \\frac{1}{N}\\sum_{n=0}^{N-1}  F_n e^{i\\eta_n j}.\n",
        "$$\n",
        "\n",
        "- \"Democratic\" definition would have $1/\\sqrt{N}$ in both definitions\n",
        "\n",
        " - DFT then change of basis to orthonormal basis $e^{(n)}_j = \\frac{e^{i\\eta_n j}}{\\sqrt{N}}$\n",
        " \n",
        " - Both DFT and its inverse then unitary \n",
        "\n",
        "---\n",
        "\n",
        "- Fourier transforms with complex exponentials have positive and negative frequencies\n",
        "\n",
        "- Here $\\eta_n$ values for $n$ close to $N-1$ are the negative frequencies since $e^{-i\\eta_n j}=e^{2\\pi ij -i\\eta_n j}=e^{i\\eta_{N - n}j}$\n",
        "\n",
        "- Several limits to consider...\n",
        "\n",
        "## $N\\to\\infty$ limit\n",
        "\n",
        "- $\\eta_n$ values become dense in range $(-\\pi,\\pi]$, with separation $\\Delta \\eta = 2\\pi/N$\n",
        "\n",
        "- Replace sum in IDFT integral according to:\n",
        "$$\n",
        "\\sum_{n=0}^{N-1} \\left(\\cdots\\right) \\xrightarrow{N\\to\\infty} N \\int_{0}^{2\\pi} \\frac{d\\eta}{2\\pi}\\left(\\cdots\\right)\n",
        "$$\n",
        "$$\n",
        "f_j = \\int_{0}^{2\\pi} \\frac{d\\eta}{2\\pi}\\,F(\\eta) e^{i\\eta j}\n",
        "$$\n",
        "\n",
        "## $N\\to\\infty$ with $f_j = f(jL/N)$\n",
        "\n",
        "- $N\\to\\infty$ limit samples $f(x)$ ever more finely in range (0,L]\n",
        "\n",
        "- Now DFT becomes an integral\n",
        "$$\n",
        "\\hat f(k) \\equiv \\int_0^L f(x) e^{-ik_n x}\\,dx,\n",
        "$$\n",
        "where $k_n =2\\pi n/L$. Note that $k_n x = \\eta_n j$. \n",
        "$$\n",
        "\\begin{align}\n",
        "\\hat f_k &= \\int_0^L f(x) e^{-ik_n x}\\,dx\\nonumber\\\\\n",
        "f(x) &= \\frac{1}{L}\\sum_k \\hat f_k e^{ik_n x}\n",
        "\\end{align} \n",
        "$$\n",
        "\n",
        "---\n",
        "\n",
        "$$\n",
        "\\begin{align}\n",
        "\\hat f_k &= \\int_0^L f(x) e^{-ik_n x}\\,dx\\nonumber\\\\\n",
        "f(x) &= \\frac{1}{L}\\sum_k \\hat f_k e^{ik_n x}\n",
        "\\end{align} \n",
        "$$\n",
        "\n",
        "- Now $\\hat f_k$ has extra dimension of distance (on account of integral), which gets removed by the $1/L$ in inverse\n",
        "$$\n",
        " \\frac{1}{L}\\sum_k e^{ik x} = \\delta_L(x)\n",
        "$$\n",
        "$\\delta_L(x)$ is an $L$-periodic version of the $\\delta$-function.\n",
        "\n",
        "## $L\\to\\infty$\n",
        "\n",
        "- Finally __Fourier transform__, where we take $L\\to\\infty$, so that inverse transform becomes an integral too\n",
        "$$\n",
        "\\begin{align}\n",
        "\\hat{f}(k) & = \\int_{-\\infty}^\\infty f(x) e^{-ik_n x}\\,dx\\nonumber\\\\\n",
        "f(x) &= \\int_{-\\infty}^\\infty \\hat f(k) e^{ik_n x}\\,\\frac{dk}{2\\pi}\n",
        "\\label{coll_FTTrans}\n",
        "\\end{align}\n",
        "$$\n",
        "\n",
        "## Some important properties {#sec-properties}\n",
        "\n",
        "- Some properties of DFT (and all of the above)\n",
        "\n",
        "1. If $f_j$ is real then $F_n = \\left[F_{-n}\\right]^*$.\n",
        "\n",
        "2. If $f_j$ is even (odd), $F_n$ is even (odd).\n",
        "\n",
        "3. (Ergo) if $f_j$ is real and even, so is $F_n$.\n",
        "\n",
        "## Higher dimensions\n",
        "\n",
        "- Generalizes to higher dimensions straightforwardly\n",
        "\n",
        "- If data lives $d$ dimensions with $N_i$ datapoints along dimension $i=1,\\dots d$\n",
        "$$\n",
        "F_{\\mathbf{n}} = \\sum_{\\mathbf{n}} f_\\mathbf{j}e^{-i \\boldsymbol{\\eta}_\\mathbf{n}\\cdot \\mathbf{j}}\n",
        "$$\n",
        "$\\mathbf{j}=(j_1,\\ldots j_{d})$ with $j_i = 0,\\ldots N_i - 1$ and $\\boldsymbol{\\eta}_\\mathbf{n} = 2\\pi (n_1 / N_1, \\ldots n_d/ N_d)$ $n_i = 0,\\ldots N_i - 1$ \n",
        "\n",
        "# Fast Fourier transform\n",
        "\n",
        "$$\n",
        "F_n = \\sum_{j=0}^{N-1} f_j e^{-i\\eta_n j}\n",
        "$$ \n",
        "\n",
        "- What is _complexity_ of computing the Fourier transform? \n",
        "\n",
        "- DFT is _matrix-vector multiplication_\n",
        "$$\n",
        "\\mathbf{F} = Q \\cdot \\mathbf{f}.\n",
        "$$\n",
        " where matrix has elements $Q_{n j}\\equiv e^{-i\\eta_n j}$\n",
        "\n",
        "- Naively, complexity is $O(N^2)$\n",
        "\n",
        "---\n",
        "\n",
        "- Can do a _lot_ better than this, because of structure of $Q$!\n",
        "\n",
        "- Divide and conquer pattern: break problem up into two sub-problems\n",
        "\n",
        "$$\n",
        "f^{\\text{e}}_j = f_{2j}\\qquad f^{\\text{o}}_j = f_{2j+1},\\qquad j=0,\\ldots N/2 - 1.\n",
        "$$\n",
        "\n",
        "- __Key idea:__ we are going to express DFT $F_n$ in terms of DFT of $f^\\text{e}_j$ and $f^\\text{o}_j$\n",
        "\n",
        "---\n",
        "\n",
        "- Write $\\omega_N \\equiv e^{2\\pi i/N}$, so that $e^{i\\eta_n j}=\\omega_N^{nj}$ and DFT is\n",
        "\n",
        "$$\n",
        "F_n = \\sum_{j=0}^{N-1} f_j \\omega_N^{-nj}\n",
        "$$\n",
        "$$\n",
        "\\begin{align}\n",
        "F_n &= \\sum_{j=0}^{N-1} \\omega_N^{-nj} f_j \\\\\n",
        "&=\\sum_{j=0}^{N/2-1} \\left[\\omega_N^{-2nj} f^{\\text{e}}_j + \\omega_N^{-n(2j+1)}f^{\\text{o}}_j\\right]\\\\\n",
        "&=\\sum_{j=0}^{N/2-1} \\left[\\omega_{N/2}^{-nj} f^{\\text{e}}_j + \\omega_N^{-n}\\omega_{N/2}^{-nj}f^{\\text{o}}_j\\right]\n",
        "\\end{align}\n",
        "$$\n",
        "\n",
        "---\n",
        "\n",
        "$$\n",
        "F_n =\\sum_{j=0}^{N/2-1} \\left[\\omega_{N/2}^{-nj} f^{\\text{e}}_j + \\omega_N^{-n}\\omega_{N/2}^{-nj}f^{\\text{o}}_j\\right]\n",
        "$$\n",
        "\n",
        "- Already looking like sum of two DFTs of size $N/2$\n",
        "\n",
        "- Write $n$ as\n",
        "$$\n",
        "n = (N/2)n_0 + n'\n",
        "$$\n",
        "where $n_0=0,1$ and $n'=0,\\ldots N/2 - 1$. \n",
        "\n",
        "- If $n$ a power of 2, $n_0$ is most significant bit of $n$ when written in binary and $n'$ are remaining bits\n",
        "\n",
        "---\n",
        "\n",
        "$$\n",
        "n = (N/2)n_0 + n'\n",
        "$$\n",
        "\n",
        "- Since $\\omega_{N/2}^{-jn}=\\omega_{N/2}^{-jn'}$ we have\n",
        "\n",
        "$$\n",
        "\\begin{align}\n",
        "F_n &= \\sum_{j=0}^{N/2-1} \\left[\\omega_{N/2}^{-nj} f^{\\text{e}}_j + \\omega_N^{-n}\\omega_{N/2}^{-nj}f^{\\text{o}}_j\\right]\\\\\n",
        "&=\\sum_{j=0}^{N/2-1} \\left[\\omega_{N/2}^{-n'j} f^{\\text{e}}_j + (-1)^{n_0}\\omega_N^{-n'} \\omega_{N/2}^{-n'j}f^{\\text{o}}_j\\right]\\\\\n",
        "&= F^\\text{e}_{n'} + (-1)^{n_0}\\omega_N^{-n'} F^\\text{o}_{n'}\n",
        "\\end{align}\n",
        "$$\n",
        "\n",
        "---\n",
        "\n",
        "$$\n",
        "F_n = F^\\text{e}_{n'} + (-1)^{n_0}\\omega_N^{-n'} F^\\text{o}_{n'}\n",
        "$$\n",
        "\n",
        "- If $N$ a power of 2 can repeat process until we get length 1\n",
        "\n",
        "![Butterfly diagram for the FFT Source:[Wikipedia](https://en.wikipedia.org/wiki/Fast_Fourier_transform)](../assets/FFT-butterfly.png){width=45%}\n",
        "\n",
        "---\n",
        "\n",
        "## Complexity\n",
        "\n",
        "- Clear that FFT is going to beat the naive approach\n",
        "\n",
        "- $T(N)$ is steps required to compute DFT for size $N$ input\n",
        "\n",
        "- Calculating $F^\\text{e}_{n'}$ and $F^\\text{0}_{n'}$ takes time $2T(N/2)$\n",
        "\n",
        "- Combining to evaluate $F_n$ is a further $N$ steps, so \n",
        "\n",
        "$$\n",
        "T(N) = 2T(N/2) +\\Theta(N)\n",
        "$$\n",
        "\n",
        "- This implies $T(N)=\\Theta(N\\log N)$\n",
        "\n",
        "---\n",
        "\n",
        "- What if $N$ isn't a power of 2?\n",
        "\n",
        "- Use divide and conquer strategy for any other factor $p$ of $N$\n",
        "\n",
        "- If largest prime factor of $N$ is bounded i.e. doesn't grow with $N$ this still yields $T(N)=\\Theta(N\\log N)$\n",
        "\n",
        "- If $N$ is prime you have to use [something else](https://en.wikipedia.org/wiki/Rader%27s_FFT_algorithm)\n",
        "\n",
        "- Best to ensure $N$ _is_ a power of two e.g. by choosing size of simulation appropriately or padding data with zeros\n",
        "\n",
        "## History\n",
        "\n",
        "- Modern invention of FFT is credited to @cooley1965algorithm. First to discuss complexity\n",
        "\n",
        "- Divide and conquer approach anticipated by @danielson1942some, for applications in crystallography\n",
        "\n",
        "- OG is [Carl Friedrich Gauss](https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss) in 1805 (predating even Fourier) in his astronomical studies\n",
        "\n",
        "- See @cooley1967historical for more on historical background\n",
        "\n",
        "## FFT in Python\n",
        "\n",
        "- FFT available in both NumPy (in the [`numpy.fft`](https://numpy.org/doc/stable/reference/routines.fft.html#module-numpy.fft) module) and SciPy (in [`scipy.fft`](https://docs.scipy.org/doc/scipy/reference/fft.html#module-scipy.fft)), with a more comprehensive set of functions\n",
        "\n",
        "- Our definitions are the defaults used in these modules (but always check conventions!)\n",
        "\n",
        "---\n",
        "\n",
        "- Several helper functions available to make your life easier:\n",
        "\n",
        "    1. `np.fft.fftfreq(n, d)`, which returns the _frequencies_ (not the angular frequencies) for input size $n$ and sample spacing $d$.\n",
        "    2. `np.fft.fftshift(A)` shifts data so that the zero frequency is in the centre.\n",
        "    3. `np.fft.ifftshift(A)` inverts this.\n",
        "\n",
        "## Simple example\n",
        "\n",
        "- Signal consisting of two sinusoids at 12 Hz and 34 Hz:\n"
      ],
      "id": "72c63ee2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "dt=0.01\n",
        "fftsize=256\n",
        "t=np.arange(fftsize)*dt\n",
        "#Generate some fake data at 12 Hz and 34 Hz\n",
        "y=np.cos(2*np.pi*12*t)+0.5*np.sin(2*np.pi*34*t)\n",
        "plt.plot(t,y)\n",
        "plt.xlabel(\"Time\")\n",
        "plt.show()"
      ],
      "id": "7be6df8b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "\n",
        "- Take FFT and plot vs array index\n"
      ],
      "id": "acec9b02"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "Y=np.fft.fft(y)\n",
        "plt.plot(abs(Y))"
      ],
      "id": "a15ed86f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "\n",
        "- Or against real frequency (sample spacing of $dt=0.01$)\n"
      ],
      "id": "22f8277f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "f=np.fft.fftfreq(fftsize, dt)\n",
        "# Reordering makes a tidier plot...\n",
        "Y=np.fft.fftshift(Y)\n",
        "f=np.fft.fftshift(f)\n",
        "plt.plot(f, abs(Y))\n",
        "plt.xlabel(\"Frequency / Hz\")\n",
        "plt.show()"
      ],
      "id": "ae3f2b0e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "\n",
        "- Fourier transform of real valued data has property $F_n = \\left[F_{-n}\\right]^*$:\n"
      ],
      "id": "08e8dd98"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.subplot(2,1,1); plt.plot(f,Y.real); plt.ylabel(\"Real\")\n",
        "plt.subplot(2,1,2); plt.plot(f,Y.imag); plt.ylabel(\"Imaginary\")\n",
        "plt.xlabel(\"Frequency / Hz\")\n",
        "plt.show()"
      ],
      "id": "187f7311",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Windowing\n",
        "\n",
        "- Signal a pair of sinusoids, but FFT _not_ just $\\delta$-functions\n"
      ],
      "id": "767e1ab9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.magnitude_spectrum(y, Fs=100, scale='dB')\n",
        "plt.show()"
      ],
      "id": "75dd369b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "- Because data is of _finite length_ \n",
        "\n",
        "---\n",
        "\n",
        "- _Windowing_ causes FFT to be non-zero outside the frequencies present in the signal: [spectral leakage](https://en.wikipedia.org/wiki/Spectral_leakage)\n",
        "\n",
        "- Sharp window means that FFT is effectively convolved with FT of top hat i.e. a sinc function\n",
        "\n",
        "- If window happens to contain a whole number of wavelengths of the signals present, spectral leakage does not occur\n",
        "\n",
        "---\n",
        "\n",
        "- Chose different [window functions](https://en.wikipedia.org/wiki/Window_function) e.g. with smooth edges\n",
        "\n",
        " - Rectangular / top hat window has _low dynamic range_: bad at distinguishing contributions of different amplitude even when their frequencies differ\n",
        " \n",
        " - Leakage from large peak may obscure smaller ones\n",
        " \n",
        " - It has _high resolution_: good at resolving peaks of similar amplitude that are close in frequency\n",
        " \n",
        " - Usually several options (Hamming, Tukey (him again), etc.) when using library functions that perform spectral analysis\n",
        "\n",
        "---\n",
        "\n",
        "![Importance of windowing LIGO data, from @abbott2020guide. Without appropriate windowing, entire power spectrum is dominated by spectral leakage](../assets/ligo-window.png){width=80%}\n",
        "\n",
        "# Applications of FFT\n",
        "\n",
        "- Mindboggling number of applications from signal processing in experimental data, audio and video signals, to numerical simulation\n",
        "\n",
        "- We'll look at two examples...\n",
        "\n",
        "## Signal processing\n",
        "\n",
        "- Time series data from LIGO and Virgo experiments on [gravitational wave detection](https://en.wikipedia.org/wiki/First_observation_of_gravitational_waves) that led to the 2017 Nobel prize in physics\n",
        "\n",
        "- See @abbott2020guide for details, as well as [accompanying notebook](https://github.com/losc-tutorial/Data_Guide/blob/master/Guide_Notebook.ipynb) that describes how analysis is performed in Python\n",
        "\n",
        "---\n",
        "\n",
        "![Stages in analysis of LIGO strain data,from @abbott2020guide. Note scale on $y$-axis!](../assets/ligo-stages.png){width=60%}\n",
        "\n",
        "---\n",
        "\n",
        "- Uncovering the signal in the raw data involves a number of processing steps designed to eliminate noise, mostly carried out in Fourier domain\n",
        "\n",
        "- Guiding principle is that the noise is _stationary_ — described by a random process that does not change in time — while signal is _transient_\n",
        "\n",
        "- This idea can be used to reduce noise in the data even though low frequency noise completely dominates the raw measurement (top panel)\n",
        "\n",
        "---\n",
        "\n",
        "- First step is windowing to reduce spectral leakage\n",
        "\n",
        "- Next, data is _whitened_: Fourier spectrum is normalized by spectral density\n",
        "$$\n",
        "\\tilde d(f)\\longrightarrow \\frac{\\tilde d(f)}{S_n^{1/2}(f)}\n",
        "$$\n",
        "\n",
        "- Idea is to prevent high amplitude noise in certain parts of the spectrum from swamping the signal\n",
        "\n",
        "- After this step (third panel, red trace), the low frequency noise has been greatly reduced\n",
        "\n",
        "---\n",
        "\n",
        "- Finally, filter with a pass band [35 Hz, 350 Hz], removing low frequency seismic noise and high frequency (quantum) noise from detector\n",
        "\n",
        "- Filtering is Fourier analog of windowing\n",
        "\n",
        "- At this point, a transient is revealed in the data (bottom panel)\n",
        "\n",
        "---\n",
        "\n",
        "- Fit transient with a model that describes graviational wave physics\n",
        "\n",
        "- Important check is to analyze _residual_ — difference between data and model — and to check whether it is described by a stationary noise process \n",
        "\n",
        "- The phases of Fourier components should be random and uncorrelated, for example\n",
        "\n",
        "---\n",
        "\n",
        "![Residuals from the modelled signal, from @abbott2020guide](../assets/ligo-residuals.png){width=60%}\n",
        "\n",
        "\n",
        "## Partial differential equations\n",
        "\n",
        "- [Spectral methods](https://en.wikipedia.org/wiki/Spectral_method) exploit FFT as part of solver\n",
        "\n",
        "- Example: time-dependent Schrödinger equation\n",
        "\n",
        "$$\n",
        "i\\hbar \\frac{\\partial \\psi}{\\partial t} = -\\frac{\\hbar^2}{2m}\\nabla^2 \\psi + V(\\mathbf{r})\\psi\n",
        "$$\n",
        "\n",
        "---\n",
        "\n",
        "When potential is absent, solutions are superpositions of plane waves\n",
        "\n",
        "$$\n",
        "\\Psi_\\mathbf{k}(\\mathbf{r}, t) = \\exp\\left[-i\\frac{\\hbar^2 \\mathbf{k}^2 t}{2m} +i\\mathbf{k}\\cdot\\mathbf{r}\\right]\n",
        "$$ {#eq-momentum}\n",
        "\n",
        "- If KE absent, evolution would be \n",
        "\n",
        "$$\n",
        "\\Psi(\\mathbf{r}, t) = \\Psi(\\mathbf{r}, 0)\\exp\\left[-iV(\\mathbf{r})t/\\hbar\\right]\n",
        "$$ {#eq-position}\n",
        "\n",
        "- Idea behind [split-step method](https://en.wikipedia.org/wiki/Split-step_method) is that time evolution can be approximated by alternating @eq-momentum and @eq-position\n",
        "\n",
        "- @eq-momentum requires that we express the solution in terms of plane wave components... FFT!\n",
        "\n",
        "---\n",
        "\n",
        "- Write equation in operator form as\n",
        "\n",
        "$$\n",
        "i\\hbar \\frac{\\partial \\ket{\\psi}}{\\partial t} = H\\ket{\\psi} = (T+V)\\ket{\\psi}\n",
        "$$\n",
        "\n",
        "- Solution is $\\ket{\\psi(t)} = \\exp(-iHt/\\hbar)\\ket{\\psi}(0)$\n",
        "\n",
        "- Exponential of $A+B$ obeys [Lie product formula](https://en.wikipedia.org/wiki/Lie_product_formula)\n",
        "\n",
        "$$\n",
        "e^{A+B} = \\lim_{n\\to\\infty}\\left( e^{A/n}e^{B/n}\\right)^n.\n",
        "$$\n",
        "\n",
        "---\n",
        "\n",
        "- More precisely,\n",
        "$$\n",
        "e^{xA}e^{xB} = e^{x(A+B) + O(x^2)}.\n",
        "$$\n",
        "\n",
        "- More accurate approximation is Suzuki—Trotter formula\n",
        "\n",
        "$$\n",
        "e^{xA/2}e^{xB}e^{xA/2} = e^{x(A+B) + O(x^3)}\n",
        "$$\n",
        "\n",
        "---\n",
        "\n",
        "- Here's a simple 1D example:\n"
      ],
      "id": "df1dca8b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "def split_step_schrodinger(psi_0, dx, dt, V, N, x_0 = 0., k_0 = None, m = 1.0, non_linear = False):\n",
        "\n",
        "\tlen_x = psi_0.shape[0]\n",
        "\n",
        "\tx = x_0 + dx*np.arange(len_x)\n",
        "\n",
        "\tdk_x = (2*np.pi)/(len_x*dx)\n",
        "\tif k_0 == None:\n",
        "\t\tk_0 = -np.pi/dx\n",
        "\tk_x = k_0+dk_x*np.arange(len_x)\n",
        "\n",
        "\tpsi_x = np.zeros((len_x,N), dtype = np.complex128)\n",
        "\tpsi_k = np.zeros((len_x,N), dtype = np.complex128)\n",
        "\tpsi_mod_x = np.zeros((len_x), dtype = np.complex128)\n",
        "\tpsi_mod_k = np.zeros((len_x), dtype = np.complex128)\n",
        "\tpsi_x[:,0] = psi_0\n",
        "\n",
        "\tif not non_linear:\n",
        "\t\tV_n = V(x)\n",
        "\telse:\n",
        "\t\tV_n = V(x,psi_0)\n",
        "\n",
        "\tdef _compute_psi_mod(j):\n",
        "\t\treturn (dx/np.sqrt(2*np.pi))*psi_x[:,j]*np.exp(-1.0j*k_x[0]*x)\n",
        "\n",
        "\tdef _compute_psi(j):\n",
        "\t\tpsi_x[:,j] = (np.sqrt(2*np.pi)/dx)*psi_mod_x*np.exp(1.0j*k_x[0]*x)\n",
        "\t\tpsi_k[:,j] = psi_mod_k*np.exp(-1.0j*x[0]*dk_x*np.arange(len_x))\n",
        "\n",
        "\tdef _x_half_step(j,ft = True):\n",
        "\t\tif ft == True:\n",
        "\t\t\tpsi_mod_x[:] = np.fft.ifft(psi_mod_k[:])\n",
        "\t\tif non_linear:\n",
        "\t\t\tV_n[:] = V(x,psi_x[:,j])\n",
        "\t\tpsi_mod_x[:] = psi_mod_x[:]*np.exp(-1.0j*(dt/2.)*V_n)\t\n",
        "\n",
        "\tdef _k_full_step():\n",
        "\t\tpsi_mod_k[:] = np.fft.fft(psi_mod_x[:])\n",
        "\t\tpsi_mod_k[:] = psi_mod_k[:]*np.exp(-1.0j*k_x**2*dt/(2.*m))\t\t\n",
        "\n",
        "\tdef _main_loop():\n",
        "\t\tpsi_mod_x[:] = _compute_psi_mod(0)\n",
        "\n",
        "\t\tfor i in range(N-1):\n",
        "\t\t\t_x_half_step(i,ft = False)\n",
        "\t\t\t_k_full_step()\n",
        "\t\t\t_x_half_step(i)\n",
        "\t\t\t_compute_psi(i+1)\n",
        "\n",
        "\t_main_loop()\n",
        "\n",
        "\treturn psi_x,psi_k,k_x"
      ],
      "id": "33d05979",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n"
      ],
      "id": "6dcdc932"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def oneD_gaussian(x,mean,std,k0):\n",
        "    return np.exp(-((x-mean)**2)/(4*std**2)+ 1j*x*k0)/(2*np.pi*std**2)**0.25\n",
        "\n",
        "def V(x):\n",
        "    V_x = np.zeros_like(x)\n",
        "    V_x[np.where(abs(x) < 0.5)] = 1.5\n",
        "    return V_x"
      ],
      "id": "d9b0f500",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "N_x = 2**11\n",
        "dx = 0.05\n",
        "x = dx * (np.arange(N_x) - 0.5 * N_x)\n",
        "\n",
        "dt = 0.01\n",
        "N_t = 2000\n",
        "\n",
        "p0 = 2.0\n",
        "d = np.sqrt(N_t*dt/2.)\n",
        "\n",
        "psi_0 = oneD_gaussian(x,x.max()-10.*d, d, -p0)\n",
        "\n",
        "psi_x,psi_k,k = split_step_schrodinger(psi_0, dx, dt, V, N_t, x_0 = x[0])"
      ],
      "id": "e5c81dfd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| code-summary: \"Animation code\"\n",
        "#| eval: false\n",
        "from matplotlib.animation import FuncAnimation\n",
        "\n",
        "real_psi = np.real(psi_x)\n",
        "imag_psi = np.imag(psi_x)\n",
        "absl_psi = np.absolute(psi_x)\n",
        "abs_psik = np.absolute(psi_k)\n",
        "\n",
        "fig = plt.figure(figsize = (10,10))\n",
        "ax1 = plt.subplot(211)\n",
        "line1_R = ax1.plot(x,real_psi[:,0],'b')[0]\n",
        "line1_I = ax1.plot(x,imag_psi[:,0],'r')[0]\n",
        "line1_A = ax1.plot(x,absl_psi[:,0],'k')[0]\n",
        "line_V = ax1.plot(x,0.5*V(x),'k',alpha=0.5)[0]\n",
        "ax1.set_ylim((real_psi.min(),real_psi.max()))\n",
        "ax1.set_xlim((x.min(),x.max()))\n",
        "\n",
        "ax2 = plt.subplot(212)\n",
        "line2 = ax2.plot(k,abs_psik[:,1],'k')[0]\n",
        "ax2.set_ylim((abs_psik.min(),abs_psik.max()))\n",
        "ax2.set_xlim((-10,10))\n",
        "\n",
        "def nextframe(arg):\n",
        "    line1_R.set_data(x,real_psi[:,10*arg])\n",
        "    line1_I.set_data(x,imag_psi[:,10*arg])\n",
        "    line1_A.set_data(x,absl_psi[:,10*arg])\n",
        "    line2.set_data(k,abs_psik[:,10*arg])\n",
        "    \n",
        "animate = FuncAnimation(fig, nextframe, frames = int(N_t/10), interval = 50, repeat = False)\n",
        "plt.show()"
      ],
      "id": "57dba52b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "raw",
      "metadata": {},
      "source": [
        "![Wavepacket colliding with a top hat barrier. Black line is the modulus, while red and blue are the real and imaginary parts.](../assets/gaussian-barrier.mp4)\n",
        "\n",
        "\n",
        "---"
      ],
      "id": "79a28dc8"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/opt/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}